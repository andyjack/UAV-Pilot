#!/usr/bin/perl
use v5.14;
use warnings;
use AnyEvent;
use UAV::Pilot;
use UAV::Pilot::Driver::ARDrone;
use UAV::Pilot::Driver::ARDrone::Video;
use UAV::Pilot::Driver::ARDrone::Video::Mock;
use UAV::Pilot::Control::ARDrone;
use UAV::Pilot::SDL::Events;
use UAV::Pilot::SDL::Video;
use UAV::Pilot::SDL::VideoOverlay::Reticle;
use UAV::Pilot::Video::FileDump;
use UAV::Pilot::Video::H264Decoder;
use Getopt::Long ();

use constant NAV_UPDATE_INTERVAL => 1 / 30;
use constant {
    FRONT_CAMERA  => 'front',
    BOTTOM_CAMERA => 'bottom',
};


my $IP       = '192.168.1.1';
my $FILE_IN  = '';
my $FILE_OUT = '';
my $RETICLE  = 0;
my $USE_CAMERA = FRONT_CAMERA;
Getopt::Long::GetOptions(
    'host=s'       => \$IP,
    'in=s'         => \$FILE_IN,
    'out=s'        => \$FILE_OUT,
    'reticle'      => \$RETICLE,
    'use-camera=s' => \$USE_CAMERA,
);



sub set_reticle_overlay
{
    my ($video) = @_;
    my $reticle = UAV::Pilot::SDL::VideoOverlay::Reticle->new;
    $video->register_video_overlay( $reticle );
    return 1;
}

sub set_driver_config
{
    my ($driver) = @_;

    my $camera_setting = ($USE_CAMERA eq BOTTOM_CAMERA)
        ? $driver->ARDRONE_CONFIG_VIDEO_CHANNEL_ZAP_CHANNEL_VERT
        : $driver->ARDRONE_CONFIG_VIDEO_CHANNEL_ZAP_CHANNEL_HORI;
    $driver->at_config(
        $driver->ARDRONE_CONFIG_VIDEO_VIDEO_CHANNEL,
        $camera_setting,
    );

    return 1;
}

sub set_comm_watchdog
{
    my ($driver, $cv) = @_;

    my $commwatch_timer; $commwatch_timer = AnyEvent->timer(
        after => 1,
        interval => 1.5,
        cb => sub {
            $driver->at_comwdg;
            $commwatch_timer;
        },
    );

    return 1;
}


{

    my $cv = AnyEvent->condvar;
    my $sdl_events = UAV::Pilot::SDL::Events->new({
        condvar => $cv,
    });

    my @displays = ( UAV::Pilot::SDL::Video->new );
    my @h264_handlers = UAV::Pilot::Video::H264Decoder->new({
        displays => \@displays,
    });

    my $fh = undef;
    if( $FILE_OUT ) {
        open( $fh, '>', $FILE_OUT ) or die "Can't open file '$FILE_OUT': $!\n";
        my $file_handler = UAV::Pilot::Video::FileDump->new({
            fh => $fh,
        });
        push @h264_handlers, $file_handler;
    }

    $sdl_events->register( $displays[0] );
    set_reticle_overlay( $displays[0] ) if $RETICLE;

    my $ardrone = UAV::Pilot::Driver::ARDrone->new({
        host => $IP,
    });
    $ardrone->connect;
    set_driver_config( $ardrone );
    set_comm_watchdog( $ardrone, $cv );

    my %video_args = (
        handlers => \@h264_handlers,
        condvar => $cv,
        driver  => $ardrone,
    );
    my $driver_video = $FILE_IN
        ? UAV::Pilot::Driver::ARDrone::Video::Mock->new({
            %video_args,
            file => $FILE_IN,
        })
        : UAV::Pilot::Driver::ARDrone::Video->new( \%video_args );

    my $dev = UAV::Pilot::Control::ARDrone->new({
        sender => $ardrone,
        video  => $driver_video,
    });

    $_->init_event_loop for $driver_video, $sdl_events;
    $cv->recv;

    close $fh if defined $fh;
}

__END__


=head1 SYNOPSIS

    uav_video_display \
        --host 192.168.1.1 \
        --in /path/to/file \
        --reticle

=head1 DESCRIPTION

Shows a video stream from the UAV in an SDL window.  If the C<--in> option is specified 
with a file, plays the stream from that file instead of connecting to the UAV.

The C<--reticle> option will overlay a targeting reticle.

=cut
